"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var client_exports = {};
__export(client_exports, {
  RealtimeSession: () => RealtimeSession
});
module.exports = __toCommonJS(client_exports);
var import_events = __toESM(require("events"));
var import_connection = require("../config/connection");
var import_handlers = require("./handlers");
var import_types = require("../types");
var nodeWrapper = __toESM(require("../realtime/node"));
var webWrapper = __toESM(require("../realtime/browser"));
var chromeWrapper = __toESM(require("../realtime/extension"));
var import_errors = require("../utils/errors");
class RealtimeSession {
  constructor(config) {
    this.emitter = new import_events.default();
    this.connectionConfig = new import_connection.ConnectionConfigFull(config);
    let socketImplementation = null;
    if (typeof window !== "undefined") {
      socketImplementation = new webWrapper.WebSocketWrapper();
    } else if (typeof chrome !== "undefined") {
      socketImplementation = new chromeWrapper.WebSocketWrapper();
    } else if (typeof process !== "undefined") {
      socketImplementation = new nodeWrapper.NodeWebSocketWrapper();
    } else {
      throw new import_errors.SpeechmaticsUnsupportedEnvironment();
    }
    this.rtSocketHandler = new import_handlers.RealtimeSocketHandler(
      this.bindHandlers(),
      socketImplementation
    );
  }
  bindHandlers() {
    return {
      onRecognitionStart: (data) => {
        this.emitter.emit(import_types.RealtimeMessageMessageEnum.RecognitionStarted, data);
      },
      onRecognitionEnd: () => {
        this.emitter.emit(import_types.RealtimeMessageMessageEnum.EndOfTranscript, this);
      },
      onFullReceived: (data) => {
        this.emitter.emit(import_types.RealtimeMessageMessageEnum.AddTranscript, data);
      },
      onPartialReceived: (data) => {
        this.emitter.emit(import_types.RealtimeMessageMessageEnum.AddPartialTranscript, data);
      },
      onFullTranslationReceived: (data) => {
        this.emitter.emit(import_types.RealtimeMessageMessageEnum.AddTranslation, data);
      },
      onPartialTranslationReceived: (data) => {
        this.emitter.emit(import_types.RealtimeMessageMessageEnum.AddPartialTranslation, data);
      },
      onAudioEventStartedReceived: (data) => {
        this.emitter.emit(import_types.RealtimeMessageMessageEnum.AudioEventStarted, data);
      },
      onAudioEventEndedReceived: (data) => {
        this.emitter.emit(import_types.RealtimeMessageMessageEnum.AudioEventEnded, data);
      },
      onError: (data) => {
        this.emitter.emit(import_types.RealtimeMessageMessageEnum.Error, data);
      }
    };
  }
  /**
   * Adds a listener for the specified event.
   *
   * @param event - The event to listen for. Should be one of the RealtimeMessageMessageEnum values.
   * @param listener - The callback function that will be called when the event is emitted.
   */
  addListener(event, listener) {
    this.emitter.addListener(event, listener);
  }
  /**
   * Removes a listener for the specified event.
   *
   * @param event - The event to remove the listener from. Should be one of the RealtimeMessageMessageEnum values.
   * @param listener - The callback function that will be removed.
   */
  removeListener(event, listener) {
    this.emitter.removeListener(event, listener);
  }
  /**
   * Starts the realtime transcription session.
   *
   * @param transcriptionConfig - The config for the transcription. If not provided, the default options from the config will be used.
   * @param audioFormat - The audio format of the audio data that will be sent to the server. If not provided, the default audio format from the config will be used.
   * @returns Promise that resolves when the session is started.
   */
  async start(config) {
    const runtimeKey = typeof this.connectionConfig.apiKey === "string" ? this.connectionConfig.apiKey : await this.connectionConfig.apiKey();
    let error = null;
    await this.rtSocketHandler.connect(
      `${this.connectionConfig.realtimeUrl}/${config?.transcription_config?.language || import_handlers.defaultLanguage}`,
      runtimeKey,
      this.connectionConfig.appId
    ).catch((err) => {
      error = new Error(
        `Unable to connect to RT runtime: ${JSON.stringify(err)}`
      );
    });
    if (error) {
      return Promise.reject(error);
    }
    return this.rtSocketHandler.startRecognition(config);
  }
  /**
   * Stops the realtime transcription session.
   *
   * @returns Promise that resolves when the session is stopped.
   */
  async stop() {
    return this.rtSocketHandler.stopRecognition().catch((err) => {
      return new Error(
        `Unable to stop recognition cleanly ${JSON.stringify(err)}`
      );
    });
  }
  /**
   * Sends audio data to the server.
   *
   * @param data - The audio data to send to the server. Should be a Float32Array. PCM audio.
   */
  sendAudio(data) {
    this.rtSocketHandler.sendAudioBuffer(data);
  }
  /**
   * Checks if the session is connected to the server.
   *
   * @returns True if the session is connected to the server, false otherwise.
   */
  isConnected() {
    return this.rtSocketHandler.isConnected();
  }
}
//# sourceMappingURL=client.js.map
