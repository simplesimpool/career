{
  "version": 3,
  "sources": ["../../src/realtime/node.ts"],
  "sourcesContent": ["import { ClientRequestArgs } from 'http';\nimport WebSocket, { ClientOptions } from 'ws';\nimport { ISocketWrapper } from '../types';\nimport { ModelError, RealtimeMessage } from '../types';\nimport {\n  addQueryParamsToUrl,\n  SM_APP_PARAM_NAME,\n  SM_SDK_PARAM_NAME,\n  getSmSDKVersion,\n} from '../utils/request';\nimport { SpeechmaticsUnsupportedEnvironment } from '../utils/errors';\n\n/**\n * Wraps the socket api to be more useful in async/await kind of scenarios\n */\nexport class NodeWebSocketWrapper implements ISocketWrapper {\n  private socket?: WebSocket;\n  private connectResolve?: () => void;\n  private connectReject?: (event: Event) => void;\n  private disconnectResolve?: () => void;\n\n  onDisconnect?: () => void;\n  onOpen?: () => void;\n  onMessage?: (data: RealtimeMessage) => void;\n  onError?: (event: ModelError) => void;\n\n  constructor() {\n    if (typeof process === 'undefined')\n      throw new SpeechmaticsUnsupportedEnvironment(\n        'process is undefined - are you running in node?',\n      );\n  }\n\n  async connect(\n    runtimeURL: string,\n    authToken?: string,\n    appId?: string,\n  ): Promise<void> {\n    const url = addQueryParamsToUrl(runtimeURL, {\n      [SM_SDK_PARAM_NAME]: getSmSDKVersion(),\n      [SM_APP_PARAM_NAME]: appId,\n    });\n    try {\n      let options: ClientOptions | ClientRequestArgs | undefined;\n      if (authToken)\n        options = { headers: { Authorization: `Bearer ${authToken}` } };\n      this.socket = new WebSocket(url, {\n        perMessageDeflate: false,\n        ...options,\n      });\n    } catch (error) {\n      this.connectReject?.(error as Event);\n      return Promise.reject(error);\n    }\n\n    this.socket.binaryType = 'arraybuffer';\n\n    this.socket.on('open', this.handleSocketOpen);\n    this.socket.on('error', this.handleSocketError);\n    this.socket.on('close', this.handleSocketClose);\n    this.socket.on('message', this.handleSocketMessage);\n\n    return new Promise((resolve, reject) => {\n      this.connectResolve = resolve;\n      this.connectReject = reject;\n    });\n  }\n\n  async disconnect(): Promise<void> {\n    if (this.socket && this.isOpen()) this.socket.close();\n    else return;\n\n    return new Promise((resolve) => {\n      this.disconnectResolve = resolve;\n    });\n  }\n\n  sendAudioBuffer(data: ArrayBufferLike | Blob): void {\n    if (this.socket && this.isOpen()) {\n      if (data instanceof Blob) {\n        // NOTE: Maybe we should add a log message about this potentially being poorer performance in Node\n        data.arrayBuffer().then((buf) => this.socket?.send(buf));\n      } else {\n        this.socket.send(data);\n      }\n    } else console.error('tried to send audio when socket was closed');\n  }\n\n  sendMessage(message: string): void {\n    if (this.socket && this.isOpen()) {\n      this.socket.send(message);\n    } else\n      console.error('tried to send message when socket was closed', message);\n  }\n\n  isOpen(): boolean {\n    return this.socket?.readyState === WebSocket.OPEN;\n  }\n\n  private handleSocketOpen = (): void => {\n    this.onOpen?.();\n    this.connectResolve?.();\n  };\n\n  private handleSocketError = (event: ErrorEvent): void => {\n    this.connectReject?.(event.error);\n    this.onError?.(event.error);\n  };\n\n  private handleSocketClose = (): void => {\n    if (this.socket) {\n      this.socket.off('open', this.handleSocketOpen);\n      this.socket.off('error', this.handleSocketError);\n      this.socket.off('close', this.handleSocketClose);\n      this.socket.off('message', this.handleSocketMessage);\n    }\n\n    this.onDisconnect?.();\n    this.disconnectResolve?.();\n  };\n\n  private handleSocketMessage = (message: MessageEvent): void => {\n    if (message.data) this.onMessage?.(JSON.parse(message.data.toString()));\n    if (message instanceof Buffer)\n      this.onMessage?.(JSON.parse(message.toString()));\n  };\n}\n"],
  "mappings": "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",
  "names": ["WebSocket"]
}
