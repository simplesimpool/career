"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var request_exports = {};
__export(request_exports, {
  SM_APP_PARAM_NAME: () => SM_APP_PARAM_NAME,
  SM_SDK_PARAM_NAME: () => SM_SDK_PARAM_NAME,
  addQueryParamsToUrl: () => addQueryParamsToUrl,
  addSDKInfoToRequestUrl: () => addSDKInfoToRequestUrl,
  getSmSDKVersion: () => getSmSDKVersion,
  request: () => request
});
module.exports = __toCommonJS(request_exports);
var import_errors = require("./errors");
async function request(apiKey, url, path, method = "POST", payload, params, contentType) {
  const requestOptions = {
    method,
    headers: {
      ...contentType ? { "Content-Type": contentType } : {},
      Authorization: `Bearer ${apiKey}`
    },
    body: payload
  };
  const parsedUrl = new URL(path, url);
  let fullUrl = addSDKInfoToRequestUrl(parsedUrl.href);
  if (params) {
    fullUrl = addQueryParamsToUrl(fullUrl, params);
  }
  let response;
  try {
    response = await fetch(fullUrl, requestOptions);
  } catch (err) {
    throw new import_errors.SpeechmaticsNetworkError(`Error fetching from ${path}`, err);
  }
  if (!response.ok) {
    const responseJson = await response.json();
    throw new import_errors.SpeechmaticsResponseError(responseJson);
  }
  const isPlain = contentType === "text/plain";
  let result;
  if (isPlain) {
    try {
      result = await response.text();
    } catch (err) {
      throw new import_errors.SpeechmaticsInvalidTypeError(
        "Failed to parse response text",
        err
      );
    }
  } else {
    try {
      result = await response.json();
    } catch (err) {
      throw new import_errors.SpeechmaticsInvalidTypeError(
        "Failed to parse response JSON",
        err
      );
    }
  }
  return result;
}
const SM_SDK_PARAM_NAME = "sm-sdk";
const SM_APP_PARAM_NAME = "sm-app";
function getSmSDKVersion() {
  return `js-${"4.0.0"}`;
}
function addQueryParamsToUrl(url, queryParams) {
  const parsedUrl = new URL(url);
  const params = new URLSearchParams(parsedUrl.search);
  Object.keys(queryParams).forEach((key) => {
    const value = queryParams[key];
    if (value !== void 0)
      params.append(key, `${value}`);
  });
  parsedUrl.search = params.toString();
  return parsedUrl.href;
}
function addSDKInfoToRequestUrl(url) {
  return addQueryParamsToUrl(url, { [SM_SDK_PARAM_NAME]: getSmSDKVersion() });
}
//# sourceMappingURL=request.js.map
