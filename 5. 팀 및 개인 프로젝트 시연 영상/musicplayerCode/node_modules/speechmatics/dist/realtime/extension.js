"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var extension_exports = {};
__export(extension_exports, {
  WebSocketWrapper: () => WebSocketWrapper
});
module.exports = __toCommonJS(extension_exports);
var import_request = require("../utils/request");
var import_errors = require("../utils/errors");
class WebSocketWrapper {
  constructor() {
    this.handleSocketOpen = () => {
      this.connectResolve?.();
    };
    this.handleSocketError = (event) => {
      this.onError?.(event.error);
    };
    this.handleSocketClose = () => {
      if (this.socket) {
        this.socket.removeEventListener("open", this.handleSocketOpen);
        this.socket.removeEventListener("error", this.handleSocketError);
        this.socket.removeEventListener("close", this.handleSocketClose);
        this.socket.removeEventListener("message", this.handleSocketMessage);
      }
      this.onDisconnect?.();
      this.disconnectResolve?.();
    };
    this.handleSocketMessage = (event) => {
      this.onMessage?.(JSON.parse(event.data));
    };
    if (typeof chrome.runtime === "undefined")
      throw new import_errors.SpeechmaticsUnsupportedEnvironment(
        "chrome is undefined - are you running in a background script?"
      );
  }
  async connect(runtimeURL, authToken, appId) {
    const url = (0, import_request.addQueryParamsToUrl)(runtimeURL, {
      jwt: authToken,
      [import_request.SM_SDK_PARAM_NAME]: (0, import_request.getSmSDKVersion)(),
      [import_request.SM_APP_PARAM_NAME]: appId
    });
    try {
      this.socket = new WebSocket(url);
    } catch (error) {
      this.connectReject?.(error);
      return Promise.reject(error);
    }
    this.socket.binaryType = "arraybuffer";
    this.socket.addEventListener("open", this.handleSocketOpen);
    this.socket.addEventListener("error", this.handleSocketError);
    this.socket.addEventListener("close", this.handleSocketClose);
    this.socket.addEventListener("message", this.handleSocketMessage);
    return new Promise((resolve, reject) => {
      this.connectResolve = resolve;
      this.connectReject = reject;
    });
  }
  async disconnect() {
    if (this.socket && this.isOpen())
      this.socket.close();
    else
      return;
    return new Promise((resolve) => {
      this.disconnectResolve = resolve;
    });
  }
  sendAudioBuffer(buffer) {
    if (this.socket && this.isOpen()) {
      this.socket.send(buffer);
    } else
      console.error("Tried to send audio when socket was closed");
  }
  sendMessage(message) {
    if (this.socket && this.isOpen()) {
      this.socket.send(message);
    } else
      console.error("Tried to send message when socket was closed", message);
  }
  isOpen() {
    return this.socket?.readyState === WebSocket.OPEN;
  }
}
//# sourceMappingURL=extension.js.map
