{
  "version": 3,
  "sources": ["../../src/realtime/extension.ts"],
  "sourcesContent": ["import {\n  addQueryParamsToUrl,\n  getSmSDKVersion,\n  SM_APP_PARAM_NAME,\n  SM_SDK_PARAM_NAME,\n} from '../utils/request';\nimport { ISocketWrapper } from '../types';\nimport { ModelError, RealtimeMessage } from '../types';\nimport { SpeechmaticsUnsupportedEnvironment } from '../utils/errors';\n\n/**\n * Wraps the socket api to be more useful in async/await kind of scenarios\n */\nexport class WebSocketWrapper implements ISocketWrapper {\n  private socket?: WebSocket;\n  private connectResolve?: () => void;\n  private connectReject?: (event: Event) => void;\n  private disconnectResolve?: () => void;\n\n  onDisconnect?: () => void;\n\n  onMessage?: (data: RealtimeMessage) => void;\n  onError?: (event: ModelError) => void;\n\n  constructor() {\n    if (typeof chrome.runtime === 'undefined')\n      throw new SpeechmaticsUnsupportedEnvironment(\n        'chrome is undefined - are you running in a background script?',\n      );\n  }\n\n  async connect(\n    runtimeURL: string,\n    authToken?: string,\n    appId?: string,\n  ): Promise<void> {\n    const url = addQueryParamsToUrl(runtimeURL, {\n      jwt: authToken,\n      [SM_SDK_PARAM_NAME]: getSmSDKVersion(),\n      [SM_APP_PARAM_NAME]: appId,\n    });\n\n    try {\n      this.socket = new WebSocket(url);\n    } catch (error) {\n      this.connectReject?.(error as Event);\n      return Promise.reject(error);\n    }\n\n    this.socket.binaryType = 'arraybuffer';\n\n    this.socket.addEventListener('open', this.handleSocketOpen);\n    this.socket.addEventListener('error', this.handleSocketError);\n    this.socket.addEventListener('close', this.handleSocketClose);\n    this.socket.addEventListener('message', this.handleSocketMessage);\n\n    return new Promise((resolve, reject) => {\n      this.connectResolve = resolve;\n      this.connectReject = reject;\n    });\n  }\n\n  async disconnect(): Promise<void> {\n    if (this.socket && this.isOpen()) this.socket.close();\n    else return;\n\n    return new Promise((resolve) => {\n      this.disconnectResolve = resolve;\n    });\n  }\n\n  sendAudioBuffer(buffer: ArrayBufferLike | Blob): void {\n    if (this.socket && this.isOpen()) {\n      this.socket.send(buffer);\n    } else console.error('Tried to send audio when socket was closed');\n  }\n\n  sendMessage(message: string): void {\n    if (this.socket && this.isOpen()) {\n      this.socket.send(message);\n    } else\n      console.error('Tried to send message when socket was closed', message);\n  }\n\n  isOpen(): boolean {\n    return this.socket?.readyState === WebSocket.OPEN;\n  }\n\n  private handleSocketOpen = (): void => {\n    this.connectResolve?.();\n  };\n\n  private handleSocketError = (event: Event): void => {\n    // this.connectReject?.(event);\n    this.onError?.((event as ErrorEvent).error);\n  };\n\n  private handleSocketClose = (): void => {\n    if (this.socket) {\n      this.socket.removeEventListener('open', this.handleSocketOpen);\n      this.socket.removeEventListener('error', this.handleSocketError);\n      this.socket.removeEventListener('close', this.handleSocketClose);\n      this.socket.removeEventListener('message', this.handleSocketMessage);\n    }\n\n    this.onDisconnect?.();\n    this.disconnectResolve?.();\n  };\n\n  private handleSocketMessage = (event: MessageEvent): void => {\n    this.onMessage?.(JSON.parse(event.data));\n  };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAKO;AAGP,oBAAmD;AAK5C,MAAM,iBAA2C;AAAA,EAWtD,cAAc;AAgEd,SAAQ,mBAAmB,MAAY;AACrC,WAAK,iBAAiB;AAAA,IACxB;AAEA,SAAQ,oBAAoB,CAAC,UAAuB;AAElD,WAAK,UAAW,MAAqB,KAAK;AAAA,IAC5C;AAEA,SAAQ,oBAAoB,MAAY;AACtC,UAAI,KAAK,QAAQ;AACf,aAAK,OAAO,oBAAoB,QAAQ,KAAK,gBAAgB;AAC7D,aAAK,OAAO,oBAAoB,SAAS,KAAK,iBAAiB;AAC/D,aAAK,OAAO,oBAAoB,SAAS,KAAK,iBAAiB;AAC/D,aAAK,OAAO,oBAAoB,WAAW,KAAK,mBAAmB;AAAA,MACrE;AAEA,WAAK,eAAe;AACpB,WAAK,oBAAoB;AAAA,IAC3B;AAEA,SAAQ,sBAAsB,CAAC,UAA8B;AAC3D,WAAK,YAAY,KAAK,MAAM,MAAM,IAAI,CAAC;AAAA,IACzC;AAtFE,QAAI,OAAO,OAAO,YAAY;AAC5B,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,EACJ;AAAA,EAEA,MAAM,QACJ,YACA,WACA,OACe;AACf,UAAM,UAAM,oCAAoB,YAAY;AAAA,MAC1C,KAAK;AAAA,MACL,CAAC,gCAAiB,OAAG,gCAAgB;AAAA,MACrC,CAAC,gCAAiB,GAAG;AAAA,IACvB,CAAC;AAED,QAAI;AACF,WAAK,SAAS,IAAI,UAAU,GAAG;AAAA,IACjC,SAAS,OAAO;AACd,WAAK,gBAAgB,KAAc;AACnC,aAAO,QAAQ,OAAO,KAAK;AAAA,IAC7B;AAEA,SAAK,OAAO,aAAa;AAEzB,SAAK,OAAO,iBAAiB,QAAQ,KAAK,gBAAgB;AAC1D,SAAK,OAAO,iBAAiB,SAAS,KAAK,iBAAiB;AAC5D,SAAK,OAAO,iBAAiB,SAAS,KAAK,iBAAiB;AAC5D,SAAK,OAAO,iBAAiB,WAAW,KAAK,mBAAmB;AAEhE,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,WAAK,iBAAiB;AACtB,WAAK,gBAAgB;AAAA,IACvB,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,aAA4B;AAChC,QAAI,KAAK,UAAU,KAAK,OAAO;AAAG,WAAK,OAAO,MAAM;AAAA;AAC/C;AAEL,WAAO,IAAI,QAAQ,CAAC,YAAY;AAC9B,WAAK,oBAAoB;AAAA,IAC3B,CAAC;AAAA,EACH;AAAA,EAEA,gBAAgB,QAAsC;AACpD,QAAI,KAAK,UAAU,KAAK,OAAO,GAAG;AAChC,WAAK,OAAO,KAAK,MAAM;AAAA,IACzB;AAAO,cAAQ,MAAM,4CAA4C;AAAA,EACnE;AAAA,EAEA,YAAY,SAAuB;AACjC,QAAI,KAAK,UAAU,KAAK,OAAO,GAAG;AAChC,WAAK,OAAO,KAAK,OAAO;AAAA,IAC1B;AACE,cAAQ,MAAM,gDAAgD,OAAO;AAAA,EACzE;AAAA,EAEA,SAAkB;AAChB,WAAO,KAAK,QAAQ,eAAe,UAAU;AAAA,EAC/C;AA0BF;",
  "names": []
}
