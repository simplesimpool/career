"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var handlers_exports = {};
__export(handlers_exports, {
  RealtimeSocketHandler: () => RealtimeSocketHandler,
  defaultLanguage: () => defaultLanguage
});
module.exports = __toCommonJS(handlers_exports);
var import_types = require("../types");
var import_errors = require("../utils/errors");
const defaultLanguage = "en";
const rtDefaultConfig = {
  language: defaultLanguage
};
const defaultAudioFormat = {
  type: "file"
};
class RealtimeSocketHandler {
  constructor(sub, socketWrapImplementation) {
    this.seqNoIn = 0;
    //used on both: start & stop
    //flag used to automatically disconnect when the socket is opened
    //used when stopRecognition has been called during the connecting phase and we must wait for the socket to be open before disconnecting gracefully
    this.pendingDisconnect = false;
    this.onSocketMessage = (data) => {
      switch (data.message) {
        case import_types.RealtimeMessageMessageEnum.RecognitionStarted:
          this.sub?.onRecognitionStart?.(data);
          this.startRecognitionResolve?.(data);
          break;
        case import_types.RealtimeMessageMessageEnum.AudioAdded:
          this.seqNoIn = data.seq_no || 0;
          break;
        case import_types.RealtimeMessageMessageEnum.Warning:
          this.sub?.onWarning?.(data);
          break;
        case import_types.RealtimeMessageMessageEnum.AddTranscript:
          this.seqNoIn++;
          this.sub?.onFullReceived?.(data);
          break;
        case import_types.RealtimeMessageMessageEnum.AddPartialTranscript:
          this.sub?.onPartialReceived?.(data);
          break;
        case import_types.RealtimeMessageMessageEnum.AddTranslation:
          this.seqNoIn++;
          this.sub?.onFullTranslationReceived?.(data);
          break;
        case import_types.RealtimeMessageMessageEnum.AddPartialTranslation:
          this.sub?.onPartialTranslationReceived?.(data);
          break;
        case import_types.RealtimeMessageMessageEnum.EndOfTranscript:
          this.sub?.onRecognitionEnd?.();
          this.stopRecognitionResolve?.();
          break;
        case import_types.RealtimeMessageMessageEnum.Error:
          this.sub?.onError?.(data);
          this.rejectPromise?.(data);
          break;
        case import_types.RealtimeMessageMessageEnum.Info:
          this.sub?.onInfo?.(data);
          break;
        case import_types.RealtimeMessageMessageEnum.AudioEventStarted:
          this.sub?.onAudioEventStartedReceived?.(data);
          break;
        case import_types.RealtimeMessageMessageEnum.AudioEventEnded:
          this.sub?.onAudioEventEndedReceived?.(data);
          break;
        case import_types.RealtimeMessageMessageEnum.StartRecognition:
        case import_types.RealtimeMessageMessageEnum.AddAudio:
        case import_types.RealtimeMessageMessageEnum.EndOfStream:
        case import_types.RealtimeMessageMessageEnum.SetRecognitionConfig:
        case void 0:
          throw new import_errors.SpeechmaticsUnexpectedResponse(
            `Unexpected RealtimeMessage during onSocketMessage: ${data.message}`
          );
        default:
          data.message;
          throw new import_errors.SpeechmaticsUnexpectedResponse(
            `Unexpected RealtimeMessage during onSocketMessage: ${data.message}`
          );
      }
    };
    this.onSocketDisconnect = () => {
      this.sub.onDisconnect?.();
    };
    this.onSocketOpen = () => {
      if (this.pendingDisconnect) {
        this.pendingDisconnect = false;
        this.sendStopRecognition();
      }
    };
    this.onSocketError = (error) => {
      this.sub.onError?.(error);
      this.rejectPromise?.(error);
    };
    this.sub = sub;
    this.socketWrap = socketWrapImplementation;
    this.socketWrap.onMessage = this.onSocketMessage;
    this.socketWrap.onError = this.onSocketError;
    this.socketWrap.onOpen = this.onSocketOpen;
    this.socketWrap.onDisconnect = this.onSocketDisconnect;
  }
  async connect(runtimeURL, runtimeKey, appId) {
    this.seqNoIn = 0;
    return this.socketWrap.connect(runtimeURL, runtimeKey, appId);
  }
  async disconnect() {
    return this.socketWrap.disconnect();
  }
  isConnected() {
    return this.socketWrap.isOpen();
  }
  sendAudioBuffer(data) {
    this.socketWrap.sendAudioBuffer(data);
  }
  async startRecognition(config) {
    const startRecognitionMessage = {
      transcription_config: config?.transcription_config || rtDefaultConfig,
      audio_format: config?.audio_format || defaultAudioFormat,
      translation_config: config?.translation_config,
      audio_events_config: config?.audio_events_config,
      message: "StartRecognition"
    };
    this.socketWrap.sendMessage(JSON.stringify(startRecognitionMessage));
    this.seqNoIn = 0;
    return new Promise((resolve, reject) => {
      this.startRecognitionResolve = resolve;
      this.rejectPromise = reject;
    });
  }
  sendStopRecognition() {
    const stopMessage = JSON.stringify({
      message: import_types.RealtimeMessageMessageEnum.EndOfStream,
      last_seq_no: this.seqNoIn
    });
    this.socketWrap.sendMessage(stopMessage);
  }
  async stopRecognition() {
    if (!this.socketWrap.isOpen()) {
      this.pendingDisconnect = true;
    } else {
      this.sendStopRecognition();
    }
    return new Promise((resolve, reject) => {
      this.stopRecognitionResolve = resolve;
      this.rejectPromise = reject;
    }).then(() => {
      return this.socketWrap.disconnect();
    });
  }
}
//# sourceMappingURL=handlers.js.map
