{
  "version": 3,
  "sources": ["../../src/realtime/handlers.ts"],
  "sourcesContent": ["/**\n * Speech service main api class\n */\n\nimport {\n  ModelError,\n  RealtimeMessage,\n  RealtimeMessageMessageEnum as MessagesEnum,\n  AudioAdded,\n  Warning,\n  AddTranscript,\n  AddPartialTranscript,\n  AddTranslation,\n  AddPartialTranslation,\n  Info,\n  RecognitionStarted,\n  RealtimeTranscriptionConfig,\n  ISocketWrapper,\n  SessionConfig,\n  AudioEventEnded,\n  AudioEventStarted,\n} from '../types';\nimport { SpeechmaticsUnexpectedResponse } from '../utils/errors';\n\nexport const defaultLanguage = 'en';\n\nconst rtDefaultConfig: RealtimeTranscriptionConfig = {\n  language: defaultLanguage,\n};\n\nconst defaultAudioFormat = {\n  type: 'file',\n} as const;\n\nexport class RealtimeSocketHandler {\n  private socketWrap: ISocketWrapper;\n\n  private seqNoIn = 0;\n\n  private startRecognitionResolve?: (data: RecognitionStarted) => void;\n  private stopRecognitionResolve?: (value?: unknown) => void;\n  private rejectPromise?: (error?: ModelError) => void; //used on both: start & stop\n\n  //flag used to automatically disconnect when the socket is opened\n  //used when stopRecognition has been called during the connecting phase and we must wait for the socket to be open before disconnecting gracefully\n  private pendingDisconnect = false;\n\n  private sub: Subscriber;\n\n  constructor(sub: Subscriber, socketWrapImplementation: ISocketWrapper) {\n    this.sub = sub;\n    this.socketWrap = socketWrapImplementation;\n\n    this.socketWrap.onMessage = this.onSocketMessage;\n    this.socketWrap.onError = this.onSocketError;\n    this.socketWrap.onOpen = this.onSocketOpen;\n    this.socketWrap.onDisconnect = this.onSocketDisconnect;\n  }\n\n  async connect(\n    runtimeURL: string,\n    runtimeKey?: string,\n    appId?: string,\n  ): Promise<void> {\n    this.seqNoIn = 0;\n\n    return this.socketWrap.connect(runtimeURL, runtimeKey, appId);\n  }\n\n  async disconnect(): Promise<void> {\n    return this.socketWrap.disconnect();\n  }\n\n  isConnected(): boolean {\n    return this.socketWrap.isOpen();\n  }\n\n  sendAudioBuffer(data: Blob | ArrayBufferLike): void {\n    this.socketWrap.sendAudioBuffer(data);\n  }\n\n  async startRecognition(config?: SessionConfig): Promise<RecognitionStarted> {\n    const startRecognitionMessage = {\n      transcription_config: config?.transcription_config || rtDefaultConfig,\n      audio_format: config?.audio_format || defaultAudioFormat,\n      translation_config: config?.translation_config,\n      audio_events_config: config?.audio_events_config,\n      message: 'StartRecognition',\n    };\n\n    this.socketWrap.sendMessage(JSON.stringify(startRecognitionMessage));\n\n    this.seqNoIn = 0;\n\n    return new Promise<RecognitionStarted>((resolve, reject): void => {\n      this.startRecognitionResolve = resolve;\n      this.rejectPromise = reject;\n    });\n  }\n\n  sendStopRecognition(): void {\n    const stopMessage: string = JSON.stringify({\n      message: MessagesEnum.EndOfStream,\n      last_seq_no: this.seqNoIn,\n    });\n\n    this.socketWrap.sendMessage(stopMessage);\n  }\n\n  async stopRecognition(): Promise<void> {\n    if (!this.socketWrap.isOpen()) {\n      this.pendingDisconnect = true;\n    } else {\n      this.sendStopRecognition();\n    }\n\n    return new Promise((resolve, reject): void => {\n      this.stopRecognitionResolve = resolve;\n      this.rejectPromise = reject;\n    }).then(() => {\n      return this.socketWrap.disconnect();\n    });\n  }\n\n  private onSocketMessage = (data: RealtimeMessage): void => {\n    switch (data.message) {\n      case MessagesEnum.RecognitionStarted:\n        this.sub?.onRecognitionStart?.(data as RecognitionStarted);\n        this.startRecognitionResolve?.(data as RecognitionStarted);\n        break;\n\n      case MessagesEnum.AudioAdded:\n        this.seqNoIn = (data as AudioAdded).seq_no || 0;\n        break;\n\n      case MessagesEnum.Warning:\n        this.sub?.onWarning?.(data as Warning);\n        break;\n\n      case MessagesEnum.AddTranscript:\n        this.seqNoIn++;\n        this.sub?.onFullReceived?.(data as AddTranscript);\n        break;\n\n      case MessagesEnum.AddPartialTranscript:\n        this.sub?.onPartialReceived?.(data as AddPartialTranscript);\n        break;\n\n      case MessagesEnum.AddTranslation:\n        this.seqNoIn++;\n        this.sub?.onFullTranslationReceived?.(data as AddTranslation);\n        break;\n\n      case MessagesEnum.AddPartialTranslation:\n        this.sub?.onPartialTranslationReceived?.(data as AddPartialTranslation);\n        break;\n\n      case MessagesEnum.EndOfTranscript:\n        this.sub?.onRecognitionEnd?.();\n        this.stopRecognitionResolve?.();\n        break;\n\n      case MessagesEnum.Error:\n        this.sub?.onError?.(data as ModelError);\n        this.rejectPromise?.(data as ModelError);\n        break;\n\n      case MessagesEnum.Info:\n        this.sub?.onInfo?.(data as Info);\n        break;\n\n      case MessagesEnum.AudioEventStarted:\n        this.sub?.onAudioEventStartedReceived?.(data as AudioEventStarted);\n        break;\n\n      case MessagesEnum.AudioEventEnded:\n        this.sub?.onAudioEventEndedReceived?.(data as AudioEventEnded);\n        break;\n\n      // We don't expect these messages to be received (only sent by the client)\n      case MessagesEnum.StartRecognition:\n      case MessagesEnum.AddAudio:\n      case MessagesEnum.EndOfStream:\n      case MessagesEnum.SetRecognitionConfig:\n\n      // We also don't expect undefined\n      case undefined:\n        throw new SpeechmaticsUnexpectedResponse(\n          `Unexpected RealtimeMessage during onSocketMessage: ${data.message}`,\n        );\n      default:\n        data.message satisfies never;\n        throw new SpeechmaticsUnexpectedResponse(\n          `Unexpected RealtimeMessage during onSocketMessage: ${data.message}`,\n        );\n    }\n  };\n\n  private onSocketDisconnect = () => {\n    this.sub.onDisconnect?.();\n  };\n\n  private onSocketOpen = () => {\n    if (this.pendingDisconnect) {\n      this.pendingDisconnect = false;\n      this.sendStopRecognition();\n    }\n  };\n  private onSocketError = (error: ModelError) => {\n    this.sub.onError?.(error);\n    this.rejectPromise?.(error);\n  };\n}\n\nexport type Subscriber = {\n  onRecognitionStart?: (data: RecognitionStarted) => void;\n  onRecognitionEnd?: () => void;\n  onFullReceived?: (data: AddTranscript) => void;\n  onPartialReceived?: (data: AddPartialTranscript) => void;\n  onFullTranslationReceived?: (result: AddTranslation) => void;\n  onPartialTranslationReceived?: (data: AddPartialTranslation) => void;\n  onWarning?: (data: Warning) => void;\n  onError?: (data: ModelError) => void;\n  onInfo?: (data: Info) => void;\n  onDisconnect?: () => void;\n  onAudioEventStartedReceived?: (data: AudioEventStarted) => void;\n  onAudioEventEndedReceived?: (data: AudioEventEnded) => void;\n};\n"],
  "mappings": "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",
  "names": ["MessagesEnum"]
}
