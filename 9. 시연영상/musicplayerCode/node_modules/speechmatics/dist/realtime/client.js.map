{
  "version": 3,
  "sources": ["../../src/realtime/client.ts"],
  "sourcesContent": ["import EventEmitter from 'events';\nimport { ConnectionConfig, ConnectionConfigFull } from '../config/connection';\nimport { RealtimeSocketHandler, defaultLanguage } from './handlers';\nimport {\n  RealtimeMessageMessageEnum as MessagesEnum,\n  ModelError,\n  AddTranscript,\n  AddPartialTranscript,\n  RecognitionStarted,\n  AddTranslation,\n  AddPartialTranslation,\n  SessionConfig,\n  ISocketWrapper,\n  AudioEventStarted,\n  AudioEventEnded,\n} from '../types';\nimport * as nodeWrapper from '../realtime/node';\nimport * as webWrapper from '../realtime/browser';\nimport * as chromeWrapper from '../realtime/extension';\n\nimport { EventMap } from '../types/event-map';\nimport { SpeechmaticsUnsupportedEnvironment } from '../utils/errors';\n\n/**\n * A class that represents a single realtime session. It's responsible for handling the connection and the messages.\n *\n * @param config - An apiKey string or an object of type ConnectionConfig. If only the string is provided, then the default ConnectionConfig will be used with this apiKey.\n *\n */\nexport class RealtimeSession {\n  connectionConfig: ConnectionConfigFull;\n  private emitter: EventEmitter = new EventEmitter();\n  rtSocketHandler: RealtimeSocketHandler;\n\n  constructor(config: string | ConnectionConfig) {\n    this.connectionConfig = new ConnectionConfigFull(config);\n\n    let socketImplementation: ISocketWrapper | null = null;\n    if (typeof window !== 'undefined') {\n      socketImplementation = new webWrapper.WebSocketWrapper();\n    } else if (typeof chrome !== 'undefined') {\n      socketImplementation = new chromeWrapper.WebSocketWrapper();\n    } else if (typeof process !== 'undefined') {\n      socketImplementation = new nodeWrapper.NodeWebSocketWrapper();\n    } else {\n      throw new SpeechmaticsUnsupportedEnvironment();\n    }\n\n    this.rtSocketHandler = new RealtimeSocketHandler(\n      this.bindHandlers(),\n      socketImplementation,\n    );\n  }\n\n  private bindHandlers<Subscriber>() {\n    return {\n      onRecognitionStart: (data: RecognitionStarted) => {\n        this.emitter.emit(MessagesEnum.RecognitionStarted, data);\n      },\n      onRecognitionEnd: () => {\n        this.emitter.emit(MessagesEnum.EndOfTranscript, this);\n      },\n      onFullReceived: (data: AddTranscript) => {\n        this.emitter.emit(MessagesEnum.AddTranscript, data);\n      },\n      onPartialReceived: (data: AddPartialTranscript) => {\n        this.emitter.emit(MessagesEnum.AddPartialTranscript, data);\n      },\n      onFullTranslationReceived: (data: AddTranslation) => {\n        this.emitter.emit(MessagesEnum.AddTranslation, data);\n      },\n      onPartialTranslationReceived: (data: AddPartialTranslation) => {\n        this.emitter.emit(MessagesEnum.AddPartialTranslation, data);\n      },\n      onAudioEventStartedReceived: (data: AudioEventStarted) => {\n        this.emitter.emit(MessagesEnum.AudioEventStarted, data);\n      },\n      onAudioEventEndedReceived: (data: AudioEventEnded) => {\n        this.emitter.emit(MessagesEnum.AudioEventEnded, data);\n      },\n      onError: (data: ModelError) => {\n        this.emitter.emit(MessagesEnum.Error, data);\n      },\n    };\n  }\n\n  /**\n   * Adds a listener for the specified event.\n   *\n   * @param event - The event to listen for. Should be one of the RealtimeMessageMessageEnum values.\n   * @param listener - The callback function that will be called when the event is emitted.\n   */\n  addListener<MessagesEnum extends keyof EventMap>(\n    event: MessagesEnum,\n    listener: EventMap[MessagesEnum],\n  ) {\n    this.emitter.addListener(event, listener);\n  }\n\n  /**\n   * Removes a listener for the specified event.\n   *\n   * @param event - The event to remove the listener from. Should be one of the RealtimeMessageMessageEnum values.\n   * @param listener - The callback function that will be removed.\n   */\n  removeListener<MessagesEnum extends keyof EventMap>(\n    event: MessagesEnum,\n    listener: EventMap[MessagesEnum],\n  ) {\n    this.emitter.removeListener(event, listener);\n  }\n\n  /**\n   * Starts the realtime transcription session.\n   *\n   * @param transcriptionConfig - The config for the transcription. If not provided, the default options from the config will be used.\n   * @param audioFormat - The audio format of the audio data that will be sent to the server. If not provided, the default audio format from the config will be used.\n   * @returns Promise that resolves when the session is started.\n   */\n  async start(config?: SessionConfig) {\n    //todo validate options\n\n    const runtimeKey =\n      typeof this.connectionConfig.apiKey === 'string'\n        ? this.connectionConfig.apiKey\n        : await this.connectionConfig.apiKey();\n\n    let error: Error | null = null;\n\n    await this.rtSocketHandler\n      .connect(\n        `${this.connectionConfig.realtimeUrl}/${\n          config?.transcription_config?.language || defaultLanguage\n        }`,\n        runtimeKey,\n        this.connectionConfig.appId,\n      )\n      .catch((err) => {\n        error = new Error(\n          `Unable to connect to RT runtime: ${JSON.stringify(err)}`,\n        );\n      });\n\n    if (error) {\n      return Promise.reject(error);\n    }\n\n    return this.rtSocketHandler.startRecognition(config);\n  }\n\n  /**\n   * Stops the realtime transcription session.\n   *\n   * @returns Promise that resolves when the session is stopped.\n   */\n  async stop() {\n    return this.rtSocketHandler.stopRecognition().catch((err) => {\n      return new Error(\n        `Unable to stop recognition cleanly ${JSON.stringify(err)}`,\n      );\n    });\n  }\n  /**\n   * Sends audio data to the server.\n   *\n   * @param data - The audio data to send to the server. Should be a Float32Array. PCM audio.\n   */\n  sendAudio(data: Float32Array | Buffer | Blob) {\n    this.rtSocketHandler.sendAudioBuffer(data);\n  }\n\n  /**\n   * Checks if the session is connected to the server.\n   *\n   * @returns True if the session is connected to the server, false otherwise.\n   */\n  isConnected() {\n    return this.rtSocketHandler.isConnected();\n  }\n}\n"],
  "mappings": "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",
  "names": ["EventEmitter", "MessagesEnum"]
}
