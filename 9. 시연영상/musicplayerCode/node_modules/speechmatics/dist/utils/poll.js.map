{
  "version": 3,
  "sources": ["../../src/utils/poll.ts"],
  "sourcesContent": ["/**\n *\n * @param cb polling function retuning a boolean (`false` if pending, `true` if resolved). If this rejects, then polling will stop, and the return promise rejects as well\n * @param interval number of milliseconds between each attempt, while still pending\n * @param timeout number of milliseconds after which to reject unconditionally\n * @returns a Promise which is fulfilled after a `resolved` state is returned from the function, or rejects if either the caller rejects, or timeout is exceeded\n */\nexport default function poll(\n  cb: () => Promise<boolean>,\n  interval = 500,\n  timeout = 60 * 1000,\n): Promise<void> {\n  return new Promise((resolve, reject) => {\n    let pollInterval: ReturnType<typeof setInterval> | undefined = undefined;\n\n    const errTimeout = setTimeout(() => {\n      typeof pollInterval !== 'undefined' && clearInterval(pollInterval);\n      reject(new Error(`Exceeded timeout of ${timeout} ms`));\n    }, timeout);\n\n    pollInterval = setInterval(() => {\n      cb()\n        .then((resolved) => {\n          if (resolved) {\n            clearTimeout(errTimeout);\n            clearInterval(pollInterval);\n            resolve();\n          }\n        })\n        .catch((err) => {\n          clearTimeout(errTimeout);\n          clearInterval(pollInterval);\n          reject(err);\n        });\n    }, interval);\n  });\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAOe,SAAR,KACL,IACA,WAAW,KACX,UAAU,KAAK,KACA;AACf,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,QAAI,eAA2D;AAE/D,UAAM,aAAa,WAAW,MAAM;AAClC,aAAO,iBAAiB,eAAe,cAAc,YAAY;AACjE,aAAO,IAAI,MAAM,uBAAuB,OAAO,KAAK,CAAC;AAAA,IACvD,GAAG,OAAO;AAEV,mBAAe,YAAY,MAAM;AAC/B,SAAG,EACA,KAAK,CAAC,aAAa;AAClB,YAAI,UAAU;AACZ,uBAAa,UAAU;AACvB,wBAAc,YAAY;AAC1B,kBAAQ;AAAA,QACV;AAAA,MACF,CAAC,EACA,MAAM,CAAC,QAAQ;AACd,qBAAa,UAAU;AACvB,sBAAc,YAAY;AAC1B,eAAO,GAAG;AAAA,MACZ,CAAC;AAAA,IACL,GAAG,QAAQ;AAAA,EACb,CAAC;AACH;",
  "names": []
}
