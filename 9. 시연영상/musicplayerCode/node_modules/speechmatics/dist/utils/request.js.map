{
  "version": 3,
  "sources": ["../../src/utils/request.ts"],
  "sourcesContent": ["import {\n  SpeechmaticsInvalidTypeError,\n  SpeechmaticsNetworkError,\n  SpeechmaticsResponseError,\n} from './errors';\n\nexport type HttpMethod = 'GET' | 'PUT' | 'POST' | 'DELETE';\n\nexport type QueryParams = Readonly<\n  Record<string, string | number | boolean | undefined>\n>;\n\nexport async function request<T>(\n  apiKey: string,\n  url: string,\n  path: string,\n  method: HttpMethod = 'POST',\n  payload?: BodyInit | null | undefined,\n  params?: QueryParams,\n  contentType?: string,\n): Promise<T> {\n  const requestOptions: RequestInit = {\n    method,\n    headers: {\n      ...(contentType ? { 'Content-Type': contentType } : {}),\n      Authorization: `Bearer ${apiKey}`,\n    },\n    body: payload,\n  };\n\n  // Add sdk information as url query parameter\n  const parsedUrl = new URL(path, url);\n  let fullUrl = addSDKInfoToRequestUrl(parsedUrl.href);\n  if (params) {\n    fullUrl = addQueryParamsToUrl(fullUrl, params);\n  }\n\n  let response: Response;\n  try {\n    response = await fetch(fullUrl, requestOptions);\n  } catch (err) {\n    throw new SpeechmaticsNetworkError(`Error fetching from ${path}`, err);\n  }\n\n  if (!response.ok) {\n    const responseJson = await response.json();\n    throw new SpeechmaticsResponseError(responseJson);\n  }\n\n  const isPlain = contentType === 'text/plain';\n\n  let result: T;\n\n  if (isPlain) {\n    try {\n      result = (await response.text()) as T;\n    } catch (err) {\n      throw new SpeechmaticsInvalidTypeError(\n        'Failed to parse response text',\n        err,\n      );\n    }\n  } else {\n    try {\n      result = (await response.json()) as T;\n    } catch (err) {\n      throw new SpeechmaticsInvalidTypeError(\n        'Failed to parse response JSON',\n        err,\n      );\n    }\n  }\n\n  return result;\n}\n\nexport const SM_SDK_PARAM_NAME = 'sm-sdk';\nexport const SM_APP_PARAM_NAME = 'sm-app';\n\nexport function getSmSDKVersion(): string {\n  return `js-${SDK_VERSION}`;\n}\n\nexport function addQueryParamsToUrl(\n  url: string,\n  queryParams: QueryParams,\n): string {\n  const parsedUrl = new URL(url);\n  const params = new URLSearchParams(parsedUrl.search);\n  Object.keys(queryParams).forEach((key) => {\n    const value = queryParams[key];\n    if (value !== undefined) params.append(key, `${value}`);\n  });\n  parsedUrl.search = params.toString();\n  return parsedUrl.href;\n}\n\nexport function addSDKInfoToRequestUrl(url: string): string {\n  return addQueryParamsToUrl(url, { [SM_SDK_PARAM_NAME]: getSmSDKVersion() });\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAIO;AAQP,eAAsB,QACpB,QACA,KACA,MACA,SAAqB,QACrB,SACA,QACA,aACY;AACZ,QAAM,iBAA8B;AAAA,IAClC;AAAA,IACA,SAAS;AAAA,MACP,GAAI,cAAc,EAAE,gBAAgB,YAAY,IAAI,CAAC;AAAA,MACrD,eAAe,UAAU,MAAM;AAAA,IACjC;AAAA,IACA,MAAM;AAAA,EACR;AAGA,QAAM,YAAY,IAAI,IAAI,MAAM,GAAG;AACnC,MAAI,UAAU,uBAAuB,UAAU,IAAI;AACnD,MAAI,QAAQ;AACV,cAAU,oBAAoB,SAAS,MAAM;AAAA,EAC/C;AAEA,MAAI;AACJ,MAAI;AACF,eAAW,MAAM,MAAM,SAAS,cAAc;AAAA,EAChD,SAAS,KAAK;AACZ,UAAM,IAAI,uCAAyB,uBAAuB,IAAI,IAAI,GAAG;AAAA,EACvE;AAEA,MAAI,CAAC,SAAS,IAAI;AAChB,UAAM,eAAe,MAAM,SAAS,KAAK;AACzC,UAAM,IAAI,wCAA0B,YAAY;AAAA,EAClD;AAEA,QAAM,UAAU,gBAAgB;AAEhC,MAAI;AAEJ,MAAI,SAAS;AACX,QAAI;AACF,eAAU,MAAM,SAAS,KAAK;AAAA,IAChC,SAAS,KAAK;AACZ,YAAM,IAAI;AAAA,QACR;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF,OAAO;AACL,QAAI;AACF,eAAU,MAAM,SAAS,KAAK;AAAA,IAChC,SAAS,KAAK;AACZ,YAAM,IAAI;AAAA,QACR;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEO,MAAM,oBAAoB;AAC1B,MAAM,oBAAoB;AAE1B,SAAS,kBAA0B;AACxC,SAAO,MAAM,OAAW;AAC1B;AAEO,SAAS,oBACd,KACA,aACQ;AACR,QAAM,YAAY,IAAI,IAAI,GAAG;AAC7B,QAAM,SAAS,IAAI,gBAAgB,UAAU,MAAM;AACnD,SAAO,KAAK,WAAW,EAAE,QAAQ,CAAC,QAAQ;AACxC,UAAM,QAAQ,YAAY,GAAG;AAC7B,QAAI,UAAU;AAAW,aAAO,OAAO,KAAK,GAAG,KAAK,EAAE;AAAA,EACxD,CAAC;AACD,YAAU,SAAS,OAAO,SAAS;AACnC,SAAO,UAAU;AACnB;AAEO,SAAS,uBAAuB,KAAqB;AAC1D,SAAO,oBAAoB,KAAK,EAAE,CAAC,iBAAiB,GAAG,gBAAgB,EAAE,CAAC;AAC5E;",
  "names": []
}
