"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var node_exports = {};
__export(node_exports, {
  NodeWebSocketWrapper: () => NodeWebSocketWrapper
});
module.exports = __toCommonJS(node_exports);
var import_ws = __toESM(require("ws"));
var import_request = require("../utils/request");
var import_errors = require("../utils/errors");
class NodeWebSocketWrapper {
  constructor() {
    this.handleSocketOpen = () => {
      this.onOpen?.();
      this.connectResolve?.();
    };
    this.handleSocketError = (event) => {
      this.connectReject?.(event.error);
      this.onError?.(event.error);
    };
    this.handleSocketClose = () => {
      if (this.socket) {
        this.socket.off("open", this.handleSocketOpen);
        this.socket.off("error", this.handleSocketError);
        this.socket.off("close", this.handleSocketClose);
        this.socket.off("message", this.handleSocketMessage);
      }
      this.onDisconnect?.();
      this.disconnectResolve?.();
    };
    this.handleSocketMessage = (message) => {
      if (message.data)
        this.onMessage?.(JSON.parse(message.data.toString()));
      if (message instanceof Buffer)
        this.onMessage?.(JSON.parse(message.toString()));
    };
    if (typeof process === "undefined")
      throw new import_errors.SpeechmaticsUnsupportedEnvironment(
        "process is undefined - are you running in node?"
      );
  }
  async connect(runtimeURL, authToken, appId) {
    const url = (0, import_request.addQueryParamsToUrl)(runtimeURL, {
      [import_request.SM_SDK_PARAM_NAME]: (0, import_request.getSmSDKVersion)(),
      [import_request.SM_APP_PARAM_NAME]: appId
    });
    try {
      let options;
      if (authToken)
        options = { headers: { Authorization: `Bearer ${authToken}` } };
      this.socket = new import_ws.default(url, {
        perMessageDeflate: false,
        ...options
      });
    } catch (error) {
      this.connectReject?.(error);
      return Promise.reject(error);
    }
    this.socket.binaryType = "arraybuffer";
    this.socket.on("open", this.handleSocketOpen);
    this.socket.on("error", this.handleSocketError);
    this.socket.on("close", this.handleSocketClose);
    this.socket.on("message", this.handleSocketMessage);
    return new Promise((resolve, reject) => {
      this.connectResolve = resolve;
      this.connectReject = reject;
    });
  }
  async disconnect() {
    if (this.socket && this.isOpen())
      this.socket.close();
    else
      return;
    return new Promise((resolve) => {
      this.disconnectResolve = resolve;
    });
  }
  sendAudioBuffer(data) {
    if (this.socket && this.isOpen()) {
      if (data instanceof Blob) {
        data.arrayBuffer().then((buf) => this.socket?.send(buf));
      } else {
        this.socket.send(data);
      }
    } else
      console.error("tried to send audio when socket was closed");
  }
  sendMessage(message) {
    if (this.socket && this.isOpen()) {
      this.socket.send(message);
    } else
      console.error("tried to send message when socket was closed", message);
  }
  isOpen() {
    return this.socket?.readyState === import_ws.default.OPEN;
  }
}
//# sourceMappingURL=node.js.map
